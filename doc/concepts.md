Concepts and Usage
================

[TOC]

# Workflow {#concepts}

Working with openlf looks like this:
1. write component(s) which implement desired functionality(ies)
1. Generate a circuit file (.gml) using LF_Toolbox (GUI) using the component(s)
1. execute circuit (using either LF_Toolbox (GUI) or openlf (CLI))

Optional:
- change parameter of circuit (text editor or LF_Toolbox)
- run again

# General Remarks

## Constructive Processing

OpenLF makes extensive use of the external link functionality of clif/hdf5. This means that outputs are generated from inputs by taking the whole input dataset and appending the newly generated data. The output is a "new" dataset which contains the old and new data in one structure, were the old data is actually a shallow copy (a reference) to the input dataset. 

These references are even retained when writing the output dataset to disk, which means that in general openlf circuits generated clif files contain all input data as links within the generated output files. Input files never have to be modififed, allowing more repeatble and side-effect free processing.

## Partial Processing

Most high level components work on a clif::Dataset as both input and output. As a clif::Dataset can be written to disk at any time (using the writeCLIF component) it is possible to redo single processing steps by saving their input and using the saved clif file in a shortened circuit which start with a readCLIF component instead of the previous processing chain.

# Circuit Generation

See the [editor documentation](@ref editor) on how to generate a circuit.

# gml Files

The gml files used by openlf are plain human-readable text files. Parameters and component connections can be modified with a text editor.
File path parameters may use relative or absolute paths which will be interpreted relative to the working dir where openlf is executed.

# Running circuits

## Using the GUI

See the [editor documentation](@ref editor) on how to generate a circuit.

## Using the Command line Interface

To execute a circuit run:
```
openlf -c somecircuit.gml
```
Progress of individual component is also shown on the command line.

# High level (clif::Dataset) Component Programming {#hl}

High level components work on the level of clif::Dataset. The input (or/and output) is an openlf::LF:
~~~~~~~~~~~~~{.cpp}
class LF {
public:
  clif::Dataset *data;
  clif::cpath path;
}; 
~~~~~~~~~~~~~

For an example see the [component tutorial](@ref tutorial). LF::data points to the respective dataset and LF::path can (but does not need to) point to a relevant path in this dataset. For example the epi processing component writes the path of the generated disparity group into LF::path, which is used by the disparity writer to choose which datastore to write into a mesh.

To simplify memory handling it is recommended to avoid the usage of **new** within components and instead use private members which are passed as output (see below). Note that the output dataset is generated by creating a new dataset and then linking all contents to the old dataset (more details in the [tutorial](@ref tutorial)):

~~~~~~~~~~~~~{.cpp}
class mycomponent : public DspComponent {

...

private:
  LF _out;
  clif::Dataset _out_set;
};


void mycomponent::Process_(DspSignalBus& inputs, DspSignalBus& outputs)
{

//do processing
...

//generate output
_out.data = &_out_set;
_out_set.memory_link(in->data);
outputs.SetValue(0, &_out);

//add the generated output to _out_set
... 
}
~~~~~~~~~~~~~
